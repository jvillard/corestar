In a moment of insanity, I, Radu Grigore, decided to throw away lots of
perfectly functioning code, and replace it with some other lot of perfectly
functioning code.  Since the beginning, coreStar had dealt with equalities,
disequalities, uninterpreted functions, and related matters by its own.
Specifically, it had three modules (Congruence, Cterm, Clogic), the first of
which was very complicated, and the other twos heaping on top of it.  For
efficiency, it represented formulas in a very complicated way, which made it
difficult to perform operations such as ‘build P*Q out of P and Q’.  We (Rasmus
and I) tried to remedy the situation by implementing the said operations.  In
the process, we fixed several glaring bugs in the old code, and replaced them
with subtle bugs, which we were subsequently unable to repair.

Needless to say, I consider this state of affairs as unsatisfactory.

So, here is the plan, in brief format:  Discharge anything that has to do with
equalities and uninterpreted functions to an SMT solver, and keep the formula
representation inside coreStar as simple as possible.  Don't worry about
efficiency; fix it later if necessary.

Now, a bit more detail.  The main data type that we must define is that for
expressions/formulas/terms.  (I don't want to distinguish between them.) The
operations on formulas include
  - Building them from syntactic descriptions; for example, ‘make P*Q out of P
    and Q’.  This must be done by the parser, and is also useful sometimes in
    the middle of symbolic execution.
  - Convert to SMT format.
  - Bring to a normal form, which the separation prover can handle.  I think the
    normal form could simply use the same OCaml type, although it's conceptually
    a subtype.


--------------------------------------------------------------------------------
- Formula representation

The two main constructors are
  make_app : operator → formula list → formula
  make_var : string → formula
and the accompanying deconstructors are
  break_app : formula → (operator * formula list)
  break_var : formula → srting

*Why:*  Of course, this could be just a (transparent) variant type.  Why go
through the trouble to hide it behind constructors/deconstructors?  I think it's
likely that we would have to implement hash-consing [1], such that we can
determine in O(1) time whether two formulas/terms are syntactically equal.  The
old implementation was doing this by using some integer identifiers in
Congruence, which had a limited scope, meaning that it was *sometimes* possible
to compare terms quickly.

Structural equality should be tested using the function
  eq : formula → formula → bool
rather than the OCaml's polymorphic comparison =.  This way, it will be easier
to switch to a new implementation in the future.

*TODO:* I'm not sure whether [operator] should be just a string, or a variant
that identifies the operators 

Some other helpers need to be provided.  For example, instead of
  make_app Star [a; b]
it's more convenient to say
  make_star a b
But, such conveniences should be easy to implement in terms of the above.

*Why:*  Destructors are supposed to make it reasonably convenient to use pattern
matching, even if the variant type used for formulas is not transparent.


--------------------------------------------------------------------------------
- Sequent representation

The coreStar sequents have the shape
  R | P ⊢ Q
and the semantics
  if h ⊨ P * R, then h ⊨ Q * R
for some definition of ⊨.

*TODO:* I say ‘some’ because I'm not sure whether we assume the intuitionistic
definition in some essential way.  (In the past I simply assumed the
intuitionistic definition when thinking about it, but other users, such as
Jules, probably aren't.  Another way to put it: While modifying the alt-abd
branch I didn't pay attention to whether those modifications would make life
hard for Jules. Sorry.)

I *think* it might be fine to have a transparent type
  type sequent =
    { sequent_frame : formula
    ; sequent_hypothesis : formula
    ; sequent_consequence : formula }




[1] http://youtu.be/IK0G04Mry3s


vim:spell:tw=80:fo+=t:
